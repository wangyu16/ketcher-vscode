import { D3SvgElementSelection } from "../../types";
import { Vec2 } from "../../../../domain/entities";
import { SubChainNode, SequenceNode } from "../../../../domain/entities/monomer-chains/types";
import { BaseSequenceRenderer } from "./BaseSequenceRenderer";
import { Chain } from "../../../../domain/entities/monomer-chains/Chain";
import { ITwoStrandedChainItem } from "../../../../domain/entities/monomer-chains/ChainsCollection";
export declare abstract class BaseSequenceItemRenderer extends BaseSequenceRenderer {
    readonly node: SequenceNode;
    private readonly firstNodeInChainPosition;
    private readonly monomerIndexInChain;
    private readonly isLastMonomerInChain;
    private readonly chain;
    private readonly nodeIndexOverall;
    private readonly editingNodeIndexOverall;
    readonly monomerSize: {
        width: number;
        height: number;
    };
    readonly scaledMonomerPosition: Vec2;
    readonly twoStrandedNode: ITwoStrandedChainItem;
    private readonly previousRowsWithAntisense;
    private readonly editorEvents;
    textElement?: D3SvgElementSelection<SVGTextElement, void>;
    counterElement?: D3SvgElementSelection<SVGTextElement, void>;
    private selectionRectangle?;
    spacerElement?: D3SvgElementSelection<SVGGElement, void>;
    backgroundElement?: D3SvgElementSelection<SVGRectElement, void>;
    caretElement?: D3SvgElementSelection<SVGLineElement, void> | D3SvgElementSelection<SVGGElement, void>;
    antisenseNodeRenderer?: this;
    constructor(node: SequenceNode, firstNodeInChainPosition: Vec2, monomerIndexInChain: number, isLastMonomerInChain: boolean, chain: Chain, nodeIndexOverall: number, editingNodeIndexOverall: number, monomerSize: {
        width: number;
        height: number;
    }, scaledMonomerPosition: Vec2, twoStrandedNode: ITwoStrandedChainItem, previousRowsWithAntisense?: number);
    abstract get symbolToDisplay(): string;
    isEditingSymbol(editingNodeIndexOverall?: number): boolean;
    isNextSymbolEditing(editingNodeIndexOverall?: number): boolean;
    private get isSingleEmptyNode();
    protected abstract drawModification(): void;
    protected appendHover(): D3SvgElementSelection<SVGUseElement, void> | void;
    protected appendHoverAreaElement(): void;
    moveSelection(): void;
    get currentChain(): Chain;
    get currentChainNodesWithoutEmptyNodes(): SubChainNode[];
    get scaledPosition(): Vec2;
    get scaledMonomerPositionForSequence(): Vec2;
    get center(): Vec2;
    protected get isSequenceEditModeTurnedOn(): boolean | undefined;
    protected get isSequenceEditInRnaBuilderModeTurnedOn(): boolean | undefined;
    private get isAntisenseEditMode();
    private get isSyncEditMode();
    protected appendRootElement(): D3SvgElementSelection<SVGGElement, void>;
    private appendBackgroundElement;
    private appendSpacerElement;
    private get nthSeparationInRow();
    get isAntisenseNode(): boolean;
    private get hasAntisenseInChain();
    private getNodeIndexInSubgroup;
    private get counterNumber();
    private appendCounterElement;
    redrawCounter(editingNodeIndexOverall?: number): void;
    private needDisplayCounter;
    private checkIfNodeIsAmbiguousMonomerPeptide;
    private checkIfNodeIsAmbiguousMonomerNotPeptide;
    private get currentNodeNearBreakingNode();
    private inIgnoreList;
    private get subChainWithNode();
    private get ignoredNodesBeforeFirstNodeInSubChain();
    private get hasOnlyIgnoredNodesBeforeNodeInSubChain();
    private get ignoredNodesAfterLastNodeInSubChain();
    private get hasOnlyIgnoredNodesAfterNodeInChain();
    private get isSubChainNodeBeginningOfChain();
    private get isBeginningOfChain();
    private get isNodeInFirstSubChain();
    private get isBeginningOfSubChain();
    private get isLastInSubChain();
    private get isNthNodeInChain();
    showCaret(): void;
    removeCaret(): void;
    redrawCaret(editingNodeIndexOverall?: number): void;
    protected redrawBackgroundElementColor(): void;
    private appendChainStartArrow;
    private drawGreyOverlay;
    show(): void;
    drawSelection(): void;
    appendSelection(): void;
    removeSelection(): void;
    private raiseElement;
    remove(): void;
    setEnumeration(): void;
    redrawEnumeration(): void;
    redrawAttachmentPoints(): void;
    redrawAttachmentPointsCoordinates(): void;
    get enumeration(): null;
    redrawChainBeginning(): void;
    hoverAttachmentPoint(): void;
    updateAttachmentPoints(): void;
    private drawBackgroundElementHover;
    private removeBackgroundElementHover;
    private appendEvents;
    private isSubChainNode;
    setAntisenseNodeRenderer(antisenseNodeRenderer: this): void;
}
