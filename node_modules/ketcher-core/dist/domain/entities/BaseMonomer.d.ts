import { DrawingEntity, DrawingEntityConfig } from './DrawingEntity';
import { Vec2 } from "./vec2";
import { AttachmentPointName, AttachmentPointsToBonds, MonomerItemType, MonomerBond } from "../types";
import { PolymerBond } from "./PolymerBond";
import { BaseMonomerRenderer } from "../../application/render/renderers/BaseMonomerRenderer";
import { IKetAttachmentPoint } from "../../application/formatters/types/ket";
import { RnaSubChain } from "./monomer-chains/RnaSubChain";
import { ChemSubChain } from "./monomer-chains/ChemSubChain";
import { PeptideSubChain } from "./monomer-chains/PeptideSubChain";
import { SubChainNode } from "./monomer-chains/types";
import { PhosphateSubChain } from "./monomer-chains/PhosphateSubChain";
import { BaseSequenceItemRenderer } from "../../application/render/renderers/sequence/BaseSequenceItemRenderer";
import { MonomerToAtomBond } from "./MonomerToAtomBond";
import { HydrogenBond } from "./HydrogenBond";
export declare type BaseMonomerConfig = DrawingEntityConfig;
export declare const HYDROGEN_BOND_ATTACHMENT_POINT = "hydrogen";
export declare abstract class BaseMonomer extends DrawingEntity {
    renderer?: BaseMonomerRenderer | BaseSequenceItemRenderer;
    attachmentPointsToBonds: AttachmentPointsToBonds;
    chosenFirstAttachmentPointForBond: AttachmentPointName | null;
    potentialSecondAttachmentPointForBond: AttachmentPointName | null;
    chosenSecondAttachmentPointForBond: AttachmentPointName | null;
    potentialAttachmentPointsToBonds: AttachmentPointsToBonds;
    attachmentPointsVisible: boolean;
    monomerItem: MonomerItemType;
    hydrogenBonds: HydrogenBond[];
    constructor(monomerItem: MonomerItemType, _position?: Vec2, config?: BaseMonomerConfig);
    get label(): string;
    get center(): Vec2;
    get listOfAttachmentPoints(): AttachmentPointName[];
    turnOnAttachmentPointsVisibility(): void;
    turnOffAttachmentPointsVisibility(): void;
    setChosenFirstAttachmentPoint(attachmentPoint: AttachmentPointName | null): void;
    setChosenSecondAttachmentPoint(attachmentPoint: AttachmentPointName | null): void;
    setPotentialSecondAttachmentPoint(attachmentPoint: AttachmentPointName | null): void;
    setPotentialBond(attachmentPoint: string | undefined, potentialBond?: PolymerBond | HydrogenBond | null): void;
    getAttachmentPointByBond(bond: MonomerBond): AttachmentPointName | undefined;
    abstract getValidSourcePoint(monomer?: BaseMonomer): AttachmentPointName | undefined;
    abstract getValidTargetPoint(monomer: BaseMonomer): string | undefined;
    getPotentialAttachmentPointByBond(bond: PolymerBond): AttachmentPointName | undefined;
    get firstFreeAttachmentPoint(): AttachmentPointName | undefined;
    private getMaxAttachmentPointNumber;
    get R1AttachmentPoint(): AttachmentPointName | undefined;
    get R2AttachmentPoint(): AttachmentPointName | undefined;
    get hasFreeAttachmentPoint(): boolean;
    isAttachmentPointExistAndFree(attachmentPoint: AttachmentPointName): boolean;
    setRenderer(renderer: BaseMonomerRenderer | BaseSequenceItemRenderer): void;
    forEachBond(callback: (polymerBond: MonomerBond, attachmentPointName: AttachmentPointName) => void): void;
    setBond(attachmentPointName: AttachmentPointName, bond: MonomerBond): void;
    unsetBond(attachmentPointName?: AttachmentPointName, bondToDelete?: HydrogenBond | PolymerBond): void;
    get covalentBonds(): (PolymerBond | MonomerToAtomBond)[];
    get polymerBonds(): PolymerBond[];
    get monomerToAtomBonds(): MonomerToAtomBond[];
    get bonds(): Array<PolymerBond | HydrogenBond | MonomerToAtomBond>;
    get bondsSortedByLength(): Array<PolymerBond | HydrogenBond | MonomerToAtomBond>;
    get polymerBondsSortedByLength(): Array<PolymerBond | HydrogenBond>;
    get hasBonds(): boolean;
    hasHydrogenBondWithMonomer(monomer: BaseMonomer): HydrogenBond | undefined;
    hasPotentialBonds(): boolean;
    getPotentialBond(attachmentPointName: string): any;
    removeBond(polymerBond: PolymerBond): void;
    removePotentialBonds(clearSelectedPoints?: boolean): void;
    get availableAttachmentPointForBondEnd(): AttachmentPointName | undefined;
    hasAttachmentPoint(attachmentPointName: AttachmentPointName): boolean;
    get isPhosphate(): boolean;
    get usedAttachmentPointsNamesList(): AttachmentPointName[];
    get unUsedAttachmentPointsNamesList(): AttachmentPointName[];
    getBondByAttachmentPoint(attachmentPointName: AttachmentPointName): PolymerBond | MonomerToAtomBond | null | undefined;
    getPotentialBondByAttachmentPoint(attachmentPointName: AttachmentPointName): PolymerBond | MonomerToAtomBond | null | undefined;
    isAttachmentPointUsed(attachmentPointName: AttachmentPointName): boolean;
    isAttachmentPointPotentiallyUsed(attachmentPointName: AttachmentPointName): boolean;
    private getAttachmentPointDict;
    static getAttachmentPointDictFromMonomerDefinition(attachmentPoints: IKetAttachmentPoint[]): {
        attachmentPointDictionary: AttachmentPointsToBonds;
        attachmentPointsList: AttachmentPointName[];
    };
    get attachmentPointNumberToType(): {
        1: string;
        2: string;
        moreThanTwo: string;
    };
    private getMonomerDefinitionAttachmentPoints;
    get superatomAttachmentPoints(): readonly import("./sGroupAttachmentPoint").SGroupAttachmentPoint[];
    getAttachmentPointDictFromAtoms(): AttachmentPointsToBonds;
    get startBondAttachmentPoint(): AttachmentPointName | undefined;
    abstract get SubChainConstructor(): typeof RnaSubChain | typeof ChemSubChain | typeof PhosphateSubChain | typeof PeptideSubChain;
    isMonomerTypeDifferentForChaining(monomerToChain: SubChainNode | BaseMonomer): boolean;
    get isModification(): boolean;
    get sideConnections(): PolymerBond[];
    get monomerCaps(): Partial<Record<AttachmentPointName, string>> | undefined;
    recalculateAttachmentPoints(): void;
}
